Tasks
=====


Overview
--------

Application code in the Actinium kernel is represented by one or more tasks.
There are two kind of these: kernel-mode and user-mode tasks. Kernel-mode 
tasks are tightly coupled to the kernel image and are beyond the scope of
this document so the term 'task' here means 'usermode task'.


Task representation
-------------------

Tasks in the actinium are rough equivalent to a 'process' in other 
microkernels. Each task is a binary file containing task's code.
Because Actinium targets microcontrollers without a MMU, tasks are represented
by 'relocatable ELF' which is not tied to specific memory addresses.
It is expected that the task binary contains three sections:

- .text containing program code and read-only data
- .data containing data with read-write access
- .bss zero-initialized data

It is important to note that data is actually stored within .text section.
Startup code has to copy data from .text to .data because SRAM is not
initialized on MCU start.

Because of differences between relocatables generated by different tools,
i.e. RISC-V ABI defines sections like .sdata/.sbss, it is often required to
rename/re-arrange sections produced by the compiler. This step is called 
'prelinking'. The porting layer contains linker script for that purpose.


Task definition
---------------

The kernel is unaware about contents of the executable image. It is 
unspecified how the user should get number and addresses of the tasks
in the image. Currently the final linker script (which produces executable
ELF) defines special task table with regions at flash/SRAM for each task
but particular application is free to use any convenient method for that.


Relocation
----------

At the final build step the provided ldgen.sh script analyzes section sizes
and generates linker script which actually places tasks at particular 
addresses. Each task is assigned to a pair of memory regions: for flash and
for SRAM. Resulting ELF therefore contains a pair of segments for each task
and may be flashed at once.


Runtime behavior
----------------

The kernel never touches task's memory so image activation, copying the 
data segment from the flash, bss zeroing etc. have to be performed by 
the task itself. Depending on the target platform some register is used
as a full restart marker. If a call is a 'full restart' then image
reactivation has to be performed, otherwise state of data/bss sections
remain unchanged so global variables preserve their state across multiple
calls of the same task.
Task entry point is the start of the flash segment.
Stack is used only during task execution and is reused by task with the
same priority.
Tasks run in usermode so they have restricted access to some functions and
instructions, i.e. a task cannot prevent its preemption by a task with
higher priority as CPU instructions like interrupt disable/enable are not
available.


Task function
-------------

Each task contains just one actor at now represented by the main function,
just like regular C application.
The function prototype is shown below:

        uint32_t main(void* msg);

It receives message pointer as its parameter. The message type depends on
a channel the task had been subscribed to. Code of main is nonblocking,
but allowed to use any synchronous calls.
Return value is used to subscribe the calling actor to some channel it wants
to receive messages from.
There is the possibility to use calls like subscribe_to inside the main code,
in that case the main() is aborted at that point until the next activation of
the actor and values on the stack are not preserved.


Exceptions
----------

Tasks are subjected to memory access restrictions as they execute in usermode.
Exceptions during actor execution caused by incorrect memory references (or 
other errors like incorrect syscall numbers) result in actor abort.
Aborts lead to call of ac_actor_error function at the kernel side which should
perform erorr handling. For example it may log the error, send message about 
what happened to another actor or just restart the aborted actor.
It is possible to develop single actor or client/server pair in such a way that
restart behavior is well-defined.

